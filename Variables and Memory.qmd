---
title: "Variables and Memory"
format: html
---

# Variables are Memory References

First, we create a variable `my_var`.

```{python}
my_var = 10
print(my_var)
```

Let's look at the memory address of `my_var` using the `id()` function.

```{python}
print(id(my_var))
```

We can obtain the hexademical output of the memory address using `hex()`

```{python}
print(hex(id(my_var)))
```

Next, we create another variable `greeting`.

```{python}
greeting = "hello"
print(greeting)
```

The memory address of `greeting` is different from `my_var`.

```{python}
print(id(greeting))
```

```{python}
print(hex(id(greeting)))
```

Note: `my_var` is a reference (or think of it as a pointer) to the a memory object storing value 10.

Hence, we are assigning the reference of `my_var` and assigning it to `other_var`. In other words, `other_var` is also "_pointing_" to the same object in memory.

```{python}
# Sharing the same reference
other_var = my_var
```

# Reference Counting

Passing `my_var` to `getrefcount()` creates another reference.

```{python}
import sys
import ctypes
sys.getrefcount(my_var)
```

Alternatively, use `ctypes.c_long.from_address(address).value`.
Here, we just pass the memory address (an _integer_), not a reference.
It does not affect reference count.

```{python}
a = [1, 2, 3]
id(a)
```

```{python}
sys.getrefcount(a)
```

```{python}
# Much more exact as it does not +1
def ref_count(address: int):
    return ctypes.c_long.from_address(address).value
```

```{python}
ref_count(id(a))
```

`id()` released its pointer to the memory address once it finished running, hence it returns to 1 again before `ref_count()` was executed.

Alternatively, we can run

```{python}
ref_count(2359113063744)
```

```{python}
b = a
id(b)
```

```{python}
ref_count(id(a))
```

```{python}
c = a
ref_count(id(c))
```

```{python}
c = 10
ref_count(id(a))
b = None
ref_count(id(a))
```

```{python}
a_id = id(a)
a = None
ref_count(a_id)
```

```{python}
ref_count(a_id)
```

# Garbage Collection

If we create a circular reference, Python memory manager will not be able to manage it and it will cause *Memory Leak*.
Hence, we will need garbage collector.

```{python}
import ctypes
import gc
```

```{python}
def ref_count(address):
    return ctypes.c_long.from_address(address).value
```

```{python}
def object_by_id(object_id):
    for obj in gc.get_objects():
        if id(obj) == object_id:
            return "Object exists."
    return "Object not found."
```

```{python}
class A:
    def __init__(self):
        self.b = B(self)  # 1st "self" in self.b is A's "self" (a pointer holding a memory value)
        print('A: self: {0},b: {1}'.format(hex(id(self)), hex(id(self.b))))

class B:
    def __init__(self, a):  # 'self' is B, 'a' is the argument passed in from B(self)
        self.a = a  # Takes the address of A and save it inside the memory block of B
        print('B: self: {0}, a: {1}'.format(hex(id(self)), hex(id(self.a))))

gc.disable()
my_var = A()
print("ID of my_var: ", hex(id(my_var)))  # Should be equals to memory address of A.
print("ID of my_var.b: ", hex(id(my_var.b)))  # Should be equals to memory address of A.
print("ID of my_var.b.a: ", hex(id(my_var.b.a)))  # Should be equals to memory address of A. 
```

```{python}
id_a = id(my_var)
id_b = id(my_var.b)
print(hex(id_a))
print(hex(id_b))
```

```{python}
# Running in Jupyter Notebook or Quarto will return nonsensical values
# Run it in a Python terminal
ref_count(id_a)  # Should be 2 because my_var is pointing to Object A (Global Reference) and Object B is pointing to Object A (self.a = a)
ref_count(id_b)  # Should be 1 because Object A is pointing to Object B (self.b = B(self))
object_by_id(id_a)
object_by_id(id_b)
```

```{python}
# Destroying the reference between my_var and object a
my_var = None
ref_count(id_a)
ref_count(id_b)
object_by_id(id_a)
object_by_id(id_b)
```

```{python}
gc.collect()
object_by_id(id_a)
object_by_id(id_b)
```

# Dynamic vs Static Typing

```{python}
a = "hello"
type(a)
```

```{python}
a = 10
type(a)
```

```{python}
a = lambda x: x**2
a(2)
type(a)
```

```{python}
a = 3 + 4j
type()
```

# Variable -assignment

```{python}
# Different memory addresses
my_var = 10
print("my_var = 10's memory address", hex(id(my_var)))
my_var = 15
print("my_var = 15's memory address", hex(id(my_var)))
my_var = my_var + 5
print("my_var = my_var + 5's memory address", hex(id(my_var)))
```

```{python}
# Same memory address
a = 9
b = 9
print("a's memory address", hex(id(a)))
print("b's memory address", hex(id(b)))
```

# Object Mutability

```{python}
# Tuples are immutable, and for t, the integers inside it are immutable too
t = (1, 2, 3)

# Lists are mutable
a = [1, 2]
b = [3, 4]

t = (a, b)
```

```{python}
a.append(3)
b.append(5)
print(a)
print(b)
print(t)  # t is immutable, but the elements inside t were not immutable
```

```{python}
my_list = [1, 2, 3]
type(my_list)
print("Before appending: ", hex(id(my_list)))
my_list.append(4)  # Expect the same memory address because the append method only modify the internal state of my_list
print("After appending: ", hex(id(my_list)))  # Same as before
```

```{python}
my_list_1 = [1, 2, 3]
print("Before adding: ", hex(id(my_list_1)))
my_list_1 = my_list_1 + [4]  # Expect different memory address because RHS isn't modifying the internal state of my_list_1
my_list_1
print("After adding: ", hex(id(my_list_1)))  # Different
```

```{python}
my_dict = dict(key1 = 1, key2 = 'a')
my_dict
```

```{python}
print("Before adding: ", hex(id(my_dict)))
my_dict['key3'] = 10.5
my_dict
```

```{python}
print("After adding: ", hex(id(my_dict)))  # Same memory address
```

```{python}
t = (1, 2, 3)
print("Before adding: ", hex(id(t)))
```

```{python}
print("ID of t[0]: ", hex(id(t[0])))
print("ID of t[1]: ", hex(id(t[1])))
print("ID of t[2]: ", hex(id(t[2])))
```

```{python}
t = ([1, 2], [3, 4])
t
```

```{python}
t[0]
```

```{python}
t[1]
```

```{python}
t[0].append(3)
t
```

# Function Arguments and Mutability

## Immutable objects

```{python}
def process(s):
    print("Initial s's memory ID = {0}".format(hex(id(s))))
    s = s + " world"
    print("Final s's memory ID = {0}".format(hex(id(s))))
```

```{python}
my_var = "hello"
print("my_var's memory ID = {0}".format(hex(id(my_var))))
```

```{python}
process(my_var)  # Final s's memory ID changed
print("Original my_var's memory ID = {0}".format(hex(id(my_var))))  # Remained the same
print(my_var)  # Value of my_var remained unchanged
```

## Mutable objects

```{python}
def modify_list(lst):
    print("Initial lst's memory ID = {0}".format(hex(id(lst))))
    lst.append(100)
    print("Final lst's memory ID = {0}".format(hex(id(lst))))
```

```{python}
my_list = [1, 2, 3]
print("my_list's memory ID = {0}".format(hex(id(my_list))))
```

```{python}
modify_list(my_list)  # Memory ID remained unchanged
print("Original my_list's memory ID = {0}".format(hex(id(my_list))))  # Remained the same
print(my_list)  # Value of my_list changed
```

## Modifying mutable element contained in immutable object

```{python}
def modify_tuple(t):
    print("Initial t's memory ID = {0}".format(hex(id(t))))
    t[0].append(100)
    print("Final t's memory ID = {0}".format(hex(id(t))))
```

```{python}
my_tuple = ([1, 2], 'a')
print("my_tuple's memory ID = {0}".format(hex(id(my_tuple))))
```

```{python}
modify_tuple(my_tuple)  # Memory ID remained unchanged
```

```{python}
print(my_tuple)  # Value of my_tuple changed
```