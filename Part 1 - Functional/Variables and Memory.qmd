---
title: "Variables and Memory"
format: html
---

# Variables are Memory References

First, we create a variable `my_var`.

```{python}
my_var = 10
print(my_var)
```

Let's look at the memory address of `my_var` using the `id()` function.

```{python}
print(id(my_var))
```

We can obtain the hexademical output of the memory address using `hex()`

```{python}
print(hex(id(my_var)))
```

Next, we create another variable `greeting`.

```{python}
greeting = "hello"
print(greeting)
```

The memory address of `greeting` is different from `my_var`.

```{python}
print(id(greeting))
```

```{python}
print(hex(id(greeting)))
```

Note: `my_var` is a reference (or think of it as a pointer) to the a memory object storing value 10.

Hence, we are assigning the reference of `my_var` and assigning it to `other_var`. In other words, `other_var` is also "_pointing_" to the same object in memory.

```{python}
# Sharing the same reference
other_var = my_var
```

# Reference Counting

Passing `my_var` to `getrefcount()` creates another reference.

```{python}
import sys
import ctypes
sys.getrefcount(my_var)
```

Alternatively, use `ctypes.c_long.from_address(address).value`.
Here, we just pass the memory address (an _integer_), not a reference.
It does not affect reference count.

```{python}
a = [1, 2, 3]
id(a)
```

```{python}
sys.getrefcount(a)
```

```{python}
# Much more exact as it does not +1
def ref_count(address: int):
    return ctypes.c_long.from_address(address).value
```

```{python}
ref_count(id(a))
```

`id()` released its pointer to the memory address once it finished running, hence it returns to 1 again before `ref_count()` was executed.

Alternatively, we can run

```{python}
ref_count(2359113063744)
```

```{python}
b = a
id(b)
```

```{python}
ref_count(id(a))
```

```{python}
c = a
ref_count(id(c))
```

```{python}
c = 10
ref_count(id(a))
b = None
ref_count(id(a))
```

```{python}
a_id = id(a)
a = None
ref_count(a_id)
```

```{python}
ref_count(a_id)
```

# Garbage Collection

If we create a circular reference, Python memory manager will not be able to manage it and it will cause *Memory Leak*.
Hence, we will need garbage collector.

```{python}
import ctypes
import gc
```

```{python}
def ref_count(address):
    return ctypes.c_long.from_address(address).value
```

```{python}
def object_by_id(object_id):
    for obj in gc.get_objects():
        if id(obj) == object_id:
            return "Object exists."
    return "Object not found."
```

```{python}
class A:
    def __init__(self):
        self.b = B(self)  # 1st "self" in self.b is A's "self" (a pointer holding a memory value)
        print('A: self: {0},b: {1}'.format(hex(id(self)), hex(id(self.b))))

class B:
    def __init__(self, a):  # 'self' is B, 'a' is the argument passed in from B(self)
        self.a = a  # Takes the address of A and save it inside the memory block of B
        print('B: self: {0}, a: {1}'.format(hex(id(self)), hex(id(self.a))))

gc.disable()
my_var = A()
print("ID of my_var: ", hex(id(my_var)))  # Should be equals to memory address of A.
print("ID of my_var.b: ", hex(id(my_var.b)))  # Should be equals to memory address of A.
print("ID of my_var.b.a: ", hex(id(my_var.b.a)))  # Should be equals to memory address of A. 
```

```{python}
id_a = id(my_var)
id_b = id(my_var.b)
print(hex(id_a))
print(hex(id_b))
```

```{python}
# Running in Jupyter Notebook or Quarto will return nonsensical values
# Run it in a Python terminal
ref_count(id_a)  # Should be 2 because my_var is pointing to Object A (Global Reference) and Object B is pointing to Object A (self.a = a)
ref_count(id_b)  # Should be 1 because Object A is pointing to Object B (self.b = B(self))
object_by_id(id_a)
object_by_id(id_b)
```

```{python}
# Destroying the reference between my_var and object a
my_var = None
ref_count(id_a)
ref_count(id_b)
object_by_id(id_a)
object_by_id(id_b)
```

```{python}
gc.collect()
object_by_id(id_a)
object_by_id(id_b)
```

# Dynamic vs Static Typing

```{python}
a = "hello"
type(a)
```

```{python}
a = 10
type(a)
```

```{python}
a = lambda x: x**2
a(2)
type(a)
```

```{python}
a = 3 + 4j
type()
```

# Variable -assignment

```{python}
# Different memory addresses
my_var = 10
print("my_var = 10's memory address", hex(id(my_var)))
my_var = 15
print("my_var = 15's memory address", hex(id(my_var)))
my_var = my_var + 5
print("my_var = my_var + 5's memory address", hex(id(my_var)))
```

```{python}
# Same memory address
a = 9
b = 9
print("a's memory address", hex(id(a)))
print("b's memory address", hex(id(b)))
```

# Object Mutability

```{python}
# Tuples are immutable, and for t, the integers inside it are immutable too
t = (1, 2, 3)

# Lists are mutable
a = [1, 2]
b = [3, 4]

t = (a, b)
```

```{python}
a.append(3)
b.append(5)
print(a)
print(b)
print(t)  # t is immutable, but the elements inside t were not immutable
```

```{python}
my_list = [1, 2, 3]
type(my_list)
print("Before appending: ", hex(id(my_list)))
my_list.append(4)  # Expect the same memory address because the append method only modify the internal state of my_list
print("After appending: ", hex(id(my_list)))  # Same as before
```

```{python}
my_list_1 = [1, 2, 3]
print("Before adding: ", hex(id(my_list_1)))
my_list_1 = my_list_1 + [4]  # Expect different memory address because RHS isn't modifying the internal state of my_list_1
my_list_1
print("After adding: ", hex(id(my_list_1)))  # Different
```

```{python}
my_dict = dict(key1 = 1, key2 = 'a')
my_dict
```

```{python}
print("Before adding: ", hex(id(my_dict)))
my_dict['key3'] = 10.5
my_dict
```

```{python}
print("After adding: ", hex(id(my_dict)))  # Same memory address
```

```{python}
t = (1, 2, 3)
print("Before adding: ", hex(id(t)))
```

```{python}
print("ID of t[0]: ", hex(id(t[0])))
print("ID of t[1]: ", hex(id(t[1])))
print("ID of t[2]: ", hex(id(t[2])))
```

```{python}
t = ([1, 2], [3, 4])
t
```

```{python}
t[0]
```

```{python}
t[1]
```

```{python}
t[0].append(3)
t
```

# Function Arguments and Mutability

## Immutable objects

```{python}
def process(s):
    print("Initial s's memory ID = {0}".format(hex(id(s))))
    s = s + " world"
    print("Final s's memory ID = {0}".format(hex(id(s))))
```

```{python}
my_var = "hello"
print("my_var's memory ID = {0}".format(hex(id(my_var))))
```

```{python}
process(my_var)  # Final s's memory ID changed
print("Original my_var's memory ID = {0}".format(hex(id(my_var))))  # Remained the same
print(my_var)  # Value of my_var remained unchanged
```

## Mutable objects

```{python}
def modify_list(lst):
    print("Initial lst's memory ID = {0}".format(hex(id(lst))))
    lst.append(100)
    print("Final lst's memory ID = {0}".format(hex(id(lst))))
```

```{python}
my_list = [1, 2, 3]
print("my_list's memory ID = {0}".format(hex(id(my_list))))
```

```{python}
modify_list(my_list)  # Memory ID remained unchanged
print("Original my_list's memory ID = {0}".format(hex(id(my_list))))  # Remained the same
print(my_list)  # Value of my_list changed
```

## Modifying mutable element contained in immutable object

```{python}
def modify_tuple(t):
    print("Initial t's memory ID = {0}".format(hex(id(t))))
    t[0].append(100)
    print("Final t's memory ID = {0}".format(hex(id(t))))
```

```{python}
my_tuple = ([1, 2], 'a')
print("my_tuple's memory ID = {0}".format(hex(id(my_tuple))))
```

```{python}
modify_tuple(my_tuple)  # Memory ID remained unchanged
```

```{python}
print(my_tuple)  # Value of my_tuple changed
```

# Shared References and Mutability

```{python}
a = "hello"
b = a
```

```{python}
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
```

```{python}
a = "hello"
b = "hello"
```

```{python}
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
```

```{python}
b = "hello"
print("b's memory address: {0}".format(hex(id(b))))  # Changed
```

```{python}
a = 500
b = 500
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Different
```

```{python}
a = [1, 2, 3]
b = a
```

```{python}
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
```

```{python}
b.append(100)
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
```

```{python}
# Contents in b will follow a
print(a)
print(b)
```

# Variable Equality

```{python}
a = 10
b = 10
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
a = 500
b = 500
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
a = [1, 2, 3]
b = [1, 2, 3]
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
a = 10
b = 10.0
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
a = 10 + 0j
b = 10.0
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
print("Memory ID of None: {0}".format(hex(id(None))))
print("Type of None: {0}".format(type(None)))
```

```{python}
a = None
b = None
c = None
print("a is b is", a is b)
print("a is c is", a is c)
print("a is None is", a is None)
print("b is None is", b is None)
print("c is None is", a is None)
```

```{python}
def square(a):
    return a ** 2

type(square)
```

```{python}
print(type(square))
```

```{python}
f = square
```

```{python}
print("Memory ID of f: {0}".format(hex(id(f))))
print("Memory ID of square: {0}".format(hex(id(square))))  # Same
print("f is square is", f is square)
```

```{python}
def cube(a):
    return a ** 3

def select_function(fn_id):
    if fn_id == 1:
        return square
    else:
        return cube
```

```{python}
f = select_function(1)
print("Memory ID of square: {0}".format(hex(id(square))))
print("Memory ID of f: {0}".format(hex(id(f))))
print("f is square is", f is square)
```

```{python}
f = select_function(2)
print("Memory ID of cube: {0}".format(hex(id(cube))))
print("Memory ID of f: {0}".format(hex(id(f))))
print("f is cube is", f is cube)
```

```{python}
# Another way of writing
select_function(1)(2)
```

```{python}
def exec_function(fn, n):
    return fn(n)
```

```{python}
exec_function(cube, 3)
```

```{python}
exec_function(square, 3)
```

# Python Optimisation
## Interning

```{python}
[-5, 256]
```

```{python}
a = 10
b = 10
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
```

```{python}
a = -5
b = -5
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
```

```{python}
a = 256
b = 256
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
```

```{python}
a = 257
b = 257
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Different
```

```{python}
a = 10
b = int(10)
c = int('10')
d = int('1010', base = 2)
print(a, b, c, d)
print(hex(id(a)), hex(id(b)), hex(id(c)), hex(id(d)))  # Same
```

## String Interning

```{python}
a = 'hello'
b = 'hello'
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
a = 'hello world'
b = 'hello world'
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Different
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
a = '_some_weird_text_here_as_long_as_there_is_no_spaces'
b = '_some_weird_text_here_as_long_as_there_is_no_spaces'
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
import sys
import time
a = sys.intern('hello world')
b = sys.intern('hello world')
c = 'hello world'
print("a's memory address: {0}".format(hex(id(a))))
print("b's memory address: {0}".format(hex(id(b))))  # Same
print("c's memory address: {0}".format(hex(id(c))))  # Different
print("a is b is", a is b)
print("a == b is", a == b)
```

```{python}
def compare_using_equals(n):
    a = 'a long string that is not interned' * 200
    b = 'a long string that is not interned' * 200
    for i in range(n):
        if a == b:
            pass

def compare_using_interning(n):
    a = sys.intern('a long string that is not interned' * 200)
    b = sys.intern('a long string that is not interned' * 200)
    for i in range(n):
        if a is b:
            pass
```

```{python}
start = time.perf_counter()
compare_using_equals(10000000)
end = time.perf_counter()
print('Equality: ', end - start)
```

```{python}
start = time.perf_counter()
compare_using_interning(10000000)
end = time.perf_counter()
print('Interning', end - start)
```

## Peephole

```{python}
def my_func():
    a = 24 * 60
    b = (1, 2) * 5
    c = 'abc' * 3
    d = 'ab' * 11
    e = 'the quick brown fox' * 5
    f = ['a', 'b'] * 3
```

```{python}
my_func.__code__.co_consts
```

```{python}
def my_func(e):
    if e in [1, 2, 3]:
        pass

my_func.__code__.co_consts
```

```{python}
def my_func(e):
    if e in {1, 2, 3}:
        pass

my_func.__code__.co_consts
```

```{python}
import string
import time

string.ascii_letters
char_list = list(string.ascii_letters)
char_tuple = tuple(string.ascii_letters)
char_set = set(string.ascii_letters)
print(char_list)
print(char_tuple)
print(char_set)
```

```{python}
def membership_test(n, container):
    for i in range(n):
        if 'z' in container:
            pass
```

```{python}
start = time.perf_counter()
membership_test(10000000, char_list)
end = time.perf_counter()
print('List: ', end - start)
```

```{python}
start = time.perf_counter()
membership_test(10000000, char_tuple)
end = time.perf_counter()
print('Tuple: ', end - start)
```

```{python}
start = time.perf_counter()
membership_test(10000000, char_set)
end = time.perf_counter()
print('Set: ', end - start)
```